#include "a_opencl_source_map.hpp"
namespace mllm::opencl {
const char* softmax = "#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n"
                      "#define SOFTMAX_WG_SIZE 256\n"
                      "__kernel void softmax_fp32(__global const float *src,__global float *dst,\n"
                      " const int D) {\n"
                      " const int row_id=get_group_id(0);\n"
                      " const int local_id=get_local_id(0);\n"
                      " const int local_size=get_local_size(0);\n"
                      " // Move pointers to the current row\n"
                      " const __global float *src_row=src+row_id*D;\n"
                      " __global float *dst_row=dst+row_id*D;\n"
                      " // 1. Find Max\n"
                      " float thread_max=-INFINITY;\n"
                      " for (int i=local_id; i<D; i += local_size) {\n"
                      " float val=src_row[i];\n"
                      " thread_max=fmax(thread_max,val);\n"
                      " }\n"
                      " // Reduction for Max\n"
                      " __local float local_max_storage[SOFTMAX_WG_SIZE];\n"
                      " local_max_storage[local_id]=thread_max;\n"
                      " barrier(CLK_LOCAL_MEM_FENCE);\n"
                      " for (int offset=local_size/2; offset>0; offset >>= 1) {\n"
                      " if (local_id<offset) {\n"
                      " local_max_storage[local_id]=fmax(local_max_storage[local_id],\n"
                      " local_max_storage[local_id+offset]);\n"
                      " }\n"
                      " barrier(CLK_LOCAL_MEM_FENCE);\n"
                      " }\n"
                      " float row_max=local_max_storage[0];\n"
                      " // 2. Compute Sum of Exp\n"
                      " float thread_sum=0.0f;\n"
                      " for (int i=local_id; i<D; i += local_size) {\n"
                      " float val=src_row[i];\n"
                      " thread_sum += exp(val-row_max);\n"
                      " }\n"
                      " // Reduction for Sum\n"
                      " __local float local_sum_storage[SOFTMAX_WG_SIZE];\n"
                      " local_sum_storage[local_id]=thread_sum;\n"
                      " barrier(CLK_LOCAL_MEM_FENCE);\n"
                      " for (int offset=local_size/2; offset>0; offset >>= 1) {\n"
                      " if (local_id<offset) {\n"
                      " local_sum_storage[local_id] += local_sum_storage[local_id+offset];\n"
                      " }\n"
                      " barrier(CLK_LOCAL_MEM_FENCE);\n"
                      " }\n"
                      " float row_sum=local_sum_storage[0];\n"
                      " // 3. Write Output\n"
                      " for (int i=local_id; i<D; i += local_size) {\n"
                      " float val=src_row[i];\n"
                      " dst_row[i]=exp(val-row_max)/row_sum;\n"
                      " }\n"
                      "}\n"
                      "__kernel void softmax_fp16(__global const half *src,__global half *dst,\n"
                      " const int D) {\n"
                      " const int row_id=get_group_id(0);\n"
                      " const int local_id=get_local_id(0);\n"
                      " const int local_size=get_local_size(0);\n"
                      " const __global half *src_row=src+row_id*D;\n"
                      " __global half *dst_row=dst+row_id*D;\n"
                      " // 1. Find Max\n"
                      " float thread_max=-INFINITY; // Use float for accumulation/reduction to avoid\n"
                      " // overflow/precision issues\n"
                      " for (int i=local_id; i<D; i += local_size) {\n"
                      " float val=(float)src_row[i];\n"
                      " thread_max=fmax(thread_max,val);\n"
                      " }\n"
                      " __local float local_max_storage[SOFTMAX_WG_SIZE];\n"
                      " local_max_storage[local_id]=thread_max;\n"
                      " barrier(CLK_LOCAL_MEM_FENCE);\n"
                      " for (int offset=local_size/2; offset>0; offset >>= 1) {\n"
                      " if (local_id<offset) {\n"
                      " local_max_storage[local_id]=fmax(local_max_storage[local_id],\n"
                      " local_max_storage[local_id+offset]);\n"
                      " }\n"
                      " barrier(CLK_LOCAL_MEM_FENCE);\n"
                      " }\n"
                      " float row_max=local_max_storage[0];\n"
                      " // 2. Compute Sum of Exp\n"
                      " float thread_sum=0.0f;\n"
                      " for (int i=local_id; i<D; i += local_size) {\n"
                      " float val=(float)src_row[i];\n"
                      " thread_sum += exp(val-row_max);\n"
                      " }\n"
                      " __local float local_sum_storage[SOFTMAX_WG_SIZE];\n"
                      " local_sum_storage[local_id]=thread_sum;\n"
                      " barrier(CLK_LOCAL_MEM_FENCE);\n"
                      " for (int offset=local_size/2; offset>0; offset >>= 1) {\n"
                      " if (local_id<offset) {\n"
                      " local_sum_storage[local_id] += local_sum_storage[local_id+offset];\n"
                      " }\n"
                      " barrier(CLK_LOCAL_MEM_FENCE);\n"
                      " }\n"
                      " float row_sum=local_sum_storage[0];\n"
                      " // 3. Write Output\n"
                      " for (int i=local_id; i<D; i += local_size) {\n"
                      " float val=(float)src_row[i];\n"
                      " dst_row[i]=(half)(exp(val-row_max)/row_sum);\n"
                      " }\n"
                      "}\n";
}  // namespace mllm::opencl
