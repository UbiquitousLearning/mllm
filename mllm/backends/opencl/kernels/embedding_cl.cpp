#include "a_opencl_source_map.hpp"
namespace mllm::opencl {
const char* embedding = "// File name: kernel/embedding.cl\n"
                        "#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n"
                        "typedef struct {\n"
                        " half d;\n"
                        " unsigned char qs[16];\n"
                        "} block_q4_0;\n"
                        "// ============================================================================\n"
                        "// ========================== FP32 Embedding Kernel ===========================\n"
                        "// ============================================================================\n"
                        "__kernel void embedding_fp32(\n"
                        " __global const long *input_ids_long,\n"
                        " __global const float *weights,\n"
                        " __global float *output,\n"
                        " const int vocab_size,\n"
                        " const int hidden_size,\n"
                        " const int sequence_len) {\n"
                        " const int d_idx=get_global_id(0);\n"
                        " const int token_idx=get_global_id(1);\n"
                        " if (d_idx >= hidden_size || token_idx >= sequence_len) {\n"
                        " return;\n"
                        " }\n"
                        " const int token_id=(int)input_ids_long[token_idx];\n"
                        " if (token_id<0 || token_id >= vocab_size) {\n"
                        " output[token_idx*hidden_size+d_idx]=0.0f;\n"
                        " return;\n"
                        " }\n"
                        " const size_t src_idx=(size_t)token_id*hidden_size+d_idx;\n"
                        " const size_t dst_idx=(size_t)token_idx*hidden_size+d_idx;\n"
                        " output[dst_idx]=weights[src_idx];\n"
                        "}\n"
                        "// ============================================================================\n"
                        "// ========================== Q4_0 Embedding Kernel ===========================\n"
                        "// ============================================================================\n"
                        "__kernel void embedding_q4_0(\n"
                        " __global const long *input_ids_long,\n"
                        " __global const block_q4_0 *weights,\n"
                        " __global float *output,\n"
                        " const int vocab_size,\n"
                        " const int hidden_size,\n"
                        " const int sequence_len) {\n"
                        " const int d_idx=get_global_id(0);\n"
                        " const int token_idx=get_global_id(1);\n"
                        " if (d_idx >= hidden_size || token_idx >= sequence_len) {\n"
                        " return;\n"
                        " }\n"
                        " const int token_id=(int)input_ids_long[token_idx];\n"
                        " if (token_id<0 || token_id >= vocab_size) {\n"
                        " output[token_idx*hidden_size+d_idx]=0.0f;\n"
                        " return;\n"
                        " }\n"
                        " const size_t weight_idx=(size_t)token_id*hidden_size+d_idx;\n"
                        " const int block_idx=weight_idx/32;\n"
                        " const int quant_idx_in_block=weight_idx % 32;\n"
                        " const __global block_q4_0 *b=&weights[block_idx];\n"
                        " const int qs_index=quant_idx_in_block % 16;\n"
                        " const unsigned char quant_pair=b->qs[qs_index];\n"
                        " int nibble;\n"
                        " if (quant_idx_in_block<16) {\n"
                        " nibble=(quant_pair & 0x0F);\n"
                        " } else {\n"
                        " nibble=(quant_pair >> 4);\n"
                        " }\n"
                        " const float dequantized_value=(float)b->d*(float)(nibble-8);\n"
                        " const size_t dst_idx=(size_t)token_idx*hidden_size+d_idx;\n"
                        " output[dst_idx]=dequantized_value;\n"
                        "}\n"
                        "// ============================================================================\n"
                        "// ================= Q4_0 Embedding Kernel (Output: FP16) ============\n"
                        "// ============================================================================\n"
                        "__kernel void embedding_q4_0_fp16(\n"
                        " __global const long *input_ids_long,\n"
                        " __global const block_q4_0 *weights,\n"
                        " __global half *output,\n"
                        " const int vocab_size,\n"
                        " const int hidden_size,\n"
                        " const int sequence_len) {\n"
                        " const int d_idx=get_global_id(0);\n"
                        " const int token_idx=get_global_id(1);\n"
                        " if (d_idx >= hidden_size || token_idx >= sequence_len) {\n"
                        " return;\n"
                        " }\n"
                        " const int token_id=(int)input_ids_long[token_idx];\n"
                        " const size_t dst_idx=(size_t)token_idx*hidden_size+d_idx;\n"
                        " if (token_id<0 || token_id >= vocab_size) {\n"
                        " output[dst_idx]=(half)0.0f;\n"
                        " return;\n"
                        " }\n"
                        " const size_t weight_idx=(size_t)token_id*hidden_size+d_idx;\n"
                        " const int block_idx=weight_idx/32;\n"
                        " const int quant_idx_in_block=weight_idx % 32;\n"
                        " const __global block_q4_0 *b=&weights[block_idx];\n"
                        " const int qs_index=quant_idx_in_block % 16;\n"
                        " const unsigned char quant_pair=b->qs[qs_index];\n"
                        " int nibble=(quant_idx_in_block<16) ? (quant_pair & 0x0F) : (quant_pair >> 4);\n"
                        " const float dequantized_value=(float)b->d*(float)(nibble-8);\n"
                        " output[dst_idx]=(half)dequantized_value;\n"
                        "}\n";
}  // namespace mllm::opencl
