#include "a_opencl_source_map.hpp"
namespace mllm::opencl {
const char* matmul = "#define TILE_SIZE 16\n"
                     "__kernel void matmul_buffer_nt_nt(const int M,const int N,const int K,\n"
                     " __global float *A,const int A_batch_stride,\n"
                     " __global float *B,const int B_batch_stride,\n"
                     " __global float *C,const int C_batch_stride) {\n"
                     " const int m=get_global_id(0);\n"
                     " const int n=get_global_id(1);\n"
                     " const int b=get_global_id(2);\n"
                     " if (m >= M || n >= N)\n"
                     " return;\n"
                     " const int a_offset=b*A_batch_stride;\n"
                     " const int b_offset=b*B_batch_stride;\n"
                     " const int c_offset=b*C_batch_stride;\n"
                     " float sum=0.0f;\n"
                     " for (int k=0; k<K; ++k) {\n"
                     " sum += A[a_offset+m*K+k]*B[b_offset+k*N+n];\n"
                     " }\n"
                     " C[c_offset+m*N+n]=sum;\n"
                     "}\n"
                     "__kernel void\n"
                     "matmul_buffer_nt_nt_opt(const int M,const int N,const int K,\n"
                     " __global float *A,const int A_batch_stride,\n"
                     " __global float *B,const int B_batch_stride,\n"
                     " __global float *C,const int C_batch_stride) {\n"
                     " const int loc_m=get_local_id(0);\n"
                     " const int loc_n=get_local_id(1);\n"
                     " const int global_m=get_global_id(0);\n"
                     " const int global_n=get_global_id(1);\n"
                     " const int b=get_global_id(2);\n"
                     " __local float Asub[TILE_SIZE][TILE_SIZE];\n"
                     " __local float Bsub[TILE_SIZE][TILE_SIZE];\n"
                     " const int a_offset=b*A_batch_stride;\n"
                     " const int b_offset=b*B_batch_stride;\n"
                     " const int c_offset=b*C_batch_stride;\n"
                     " float sum=0.0f;\n"
                     " const int num_tiles=(K+TILE_SIZE-1)/TILE_SIZE;\n"
                     " for (int t=0; t<num_tiles; t++) {\n"
                     " const int tiled_k=t*TILE_SIZE;\n"
                     " const int a_row=global_m;\n"
                     " const int a_col=tiled_k+loc_n;\n"
                     " if (a_row<M && a_col<K) {\n"
                     " Asub[loc_m][loc_n]=A[a_offset+a_row*K+a_col];\n"
                     " } else {\n"
                     " Asub[loc_m][loc_n]=0.0f;\n"
                     " }\n"
                     " const int b_row=tiled_k+loc_m;\n"
                     " const int b_col=global_n;\n"
                     " if (b_row<K && b_col<N) {\n"
                     " Bsub[loc_m][loc_n]=B[b_offset+b_row*N+b_col];\n"
                     " } else {\n"
                     " Bsub[loc_m][loc_n]=0.0f;\n"
                     " }\n"
                     " barrier(CLK_LOCAL_MEM_FENCE);\n"
                     " for (int k=0; k<TILE_SIZE; ++k) {\n"
                     " sum += Asub[loc_m][k]*Bsub[k][loc_n];\n"
                     " }\n"
                     " barrier(CLK_LOCAL_MEM_FENCE);\n"
                     " }\n"
                     " if (global_m<M && global_n<N) {\n"
                     " C[c_offset+global_m*N+global_n]=sum;\n"
                     " }\n"
                     "}\n"
                     "__kernel void matmul_buffer_nt_t(const int M,const int N,const int K,\n"
                     " __global float *A,const int A_batch_stride,\n"
                     " __global float *B,const int B_batch_stride,\n"
                     " __global float *C,const int C_batch_stride) {\n"
                     " const int m=get_global_id(0);\n"
                     " const int n=get_global_id(1);\n"
                     " const int b=get_global_id(2);\n"
                     " if (m >= M || n >= N)\n"
                     " return;\n"
                     " const int a_offset=b*A_batch_stride;\n"
                     " const int b_offset=b*B_batch_stride;\n"
                     " const int c_offset=b*C_batch_stride;\n"
                     " float sum=0.0f;\n"
                     " for (int k=0; k<K; ++k) {\n"
                     " sum += A[a_offset+m*K+k]*B[b_offset+n*K+k];\n"
                     " }\n"
                     " C[c_offset+m*N+n]=sum;\n"
                     "}\n"
                     "__kernel void\n"
                     "matmul_buffer_nt_t_opt(const int M,const int N,const int K,__global float *A,\n"
                     " const int A_batch_stride,__global float *B,\n"
                     " const int B_batch_stride,__global float *C,\n"
                     " const int C_batch_stride) {\n"
                     " const int loc_m=get_local_id(0);\n"
                     " const int loc_n=get_local_id(1);\n"
                     " const int global_m=get_global_id(0);\n"
                     " const int global_n=get_global_id(1);\n"
                     " const int b=get_global_id(2);\n"
                     " __local float Asub[TILE_SIZE][TILE_SIZE];\n"
                     " __local float Bsub[TILE_SIZE][TILE_SIZE];\n"
                     " const int a_offset=b*A_batch_stride;\n"
                     " const int b_offset=b*B_batch_stride;\n"
                     " const int c_offset=b*C_batch_stride;\n"
                     " float sum=0.0f;\n"
                     " const int num_tiles=(K+TILE_SIZE-1)/TILE_SIZE;\n"
                     " for (int t=0; t<num_tiles; t++) {\n"
                     " const int tiled_k=t*TILE_SIZE;\n"
                     " if (global_m<M && (tiled_k+loc_n)<K) {\n"
                     " Asub[loc_m][loc_n]=A[a_offset+global_m*K+(tiled_k+loc_n)];\n"
                     " } else {\n"
                     " Asub[loc_m][loc_n]=0.0f;\n"
                     " }\n"
                     " if (global_m<M && (tiled_k+loc_n)<K) {\n"
                     " Asub[loc_m][loc_n]=A[a_offset+global_m*K+(tiled_k+loc_n)];\n"
                     " } else {\n"
                     " Asub[loc_m][loc_n]=0.0f;\n"
                     " }\n"
                     " int t_b_row=get_group_id(1)*TILE_SIZE+loc_n;\n"
                     " int t_b_col=tiled_k+loc_m;\n"
                     " if (t_b_row<N && t_b_col<K) {\n"
                     " Bsub[loc_n][loc_m]=B[b_offset+t_b_row*K+t_b_col];\n"
                     " } else {\n"
                     " Bsub[loc_n][loc_m]=0.0f;\n"
                     " }\n"
                     " barrier(CLK_LOCAL_MEM_FENCE);\n"
                     " for (int k=0; k<TILE_SIZE; ++k) {\n"
                     " sum += Asub[loc_m][k]*Bsub[loc_n][k];\n"
                     " }\n"
                     " barrier(CLK_LOCAL_MEM_FENCE);\n"
                     " }\n"
                     " if (global_m<M && global_n<N) {\n"
                     " C[c_offset+global_m*N+global_n]=sum;\n"
                     " }\n"
                     "}\n";
}  // namespace mllm::opencl
