#include "a_opencl_source_map.hpp"
namespace mllm::opencl {
const char* add = "__kernel void add_float(__global const float *A,__global const float *B,\n"
                  " __global float *C) {\n"
                  " size_t index=get_global_id(0);\n"
                  " C[index]=A[index]+B[index];\n"
                  "}\n"
                  "/*\n"
                  "*Define a global sampler. A sampler is used to configure how data is read from\n"
                  "*image objects. CLK_NORMALIZED_COORDS_FALSE: Use non-normalized integer\n"
                  "*coordinates (pixel coordinates) instead of floating point coordinates in\n"
                  "*[0.0,1.0]. CLK_ADDRESS_CLAMP_TO_EDGE: When reading coordinates beyond the\n"
                  "*image boundary,automatically return the pixel value of the nearest edge to\n"
                  "*prevent out-of-bounds reading. CLK_FILTER_NEAREST: Read the pixel closest to\n"
                  "*the coordinate without interpolation,which is essential for data\n"
                  "*calculation.\n"
                  " */\n"
                  "// const sampler_t sampler=CLK_NORMALIZED_COORDS_FALSE |\n"
                  "// CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_NEAREST;\n"
                  "/**\n"
                  "*@brief Efficiently perform element-wise addition of two float tensors using\n"
                  "*image2d_t.\n"
                  "*@param sampler Sampler object used to read images.\n"
                  "*@param inputA Input tensor A,as a read-only 2D image object.\n"
                  "*@param inputB Input tensor B,as a read-only 2D image object.\n"
                  "*@param output Output tensor C,as a write-only 2D image object.\n"
                  "*@param width Logical width of the image (in pixels).\n"
                  "*@param height Logical height of the image (in pixels).\n"
                  " */\n"
                  "__kernel void\n"
                  "add_float_image2d(sampler_t sampler,// Sampler is now the first parameter\n"
                  " __read_only image2d_t inputA,__read_only image2d_t inputB,\n"
                  " __write_only image2d_t output,const int width,\n"
                  " const int height) {\n"
                  " const int2 pos=(int2)(get_global_id(0),get_global_id(1));\n"
                  " if (pos.x >= width || pos.y >= height) {\n"
                  " return;\n"
                  " }\n"
                  " float4 inA=read_imagef(inputA,sampler,pos);\n"
                  " float4 inB=read_imagef(inputB,sampler,pos);\n"
                  " float4 result=inA+inB;\n"
                  " write_imagef(output,pos,result);\n"
                  "}\n"
                  "#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n"
                  "/**\n"
                  "*@brief [FP16 Buffer Version] Efficiently perform element-wise addition of two\n"
                  "*half tensors using vector instructions. The kernel uses vload4/vstore4 to\n"
                  "*process 4 half elements at once.\n"
                  "*@param A Input tensor A (__global const half*)\n"
                  "*@param B Input tensor B (__global const half*)\n"
                  "*@param C Output tensor C (__global half*)\n"
                  " */\n"
                  "__kernel void add_fp16_vector(__global const half *A,__global const half *B,\n"
                  " __global half *C) {\n"
                  " const int i=get_global_id(0);\n"
                  " if (i >= count/4)\n"
                  " return;\n"
                  " // Efficiently load 4 half (total 64 bits) data\n"
                  " half4 a_vec=vload4(i,A);\n"
                  " half4 b_vec=vload4(i,B);\n"
                  " // Vector addition\n"
                  " half4 c_vec=a_vec+b_vec;\n"
                  " // Efficiently write back 4 half data\n"
                  " vstore4(c_vec,i,C);\n"
                  "}\n"
                  "/**\n"
                  "*@brief [FP16 Image Version] Efficiently perform element-wise addition of two\n"
                  "*half tensors using image2d_t. Utilize hardware texture cache and\n"
                  "*read_imageh/write_imageh functions.\n"
                  "*@param sampler Sampler object used to read images.\n"
                  "*@param inputA Input tensor A,as a read-only 2D image object (data type\n"
                  "*is half).\n"
                  "*@param inputB Input tensor B,as a read-only 2D image object (data type\n"
                  "*is half).\n"
                  "*@param output Output tensor C,as a write-only 2D image object (data\n"
                  "*type is half).\n"
                  "*@param width Logical width of the image (in pixels).\n"
                  "*@param height Logical height of the image (in pixels).\n"
                  " */\n"
                  "__kernel void add_fp16_image2d(sampler_t sampler,__read_only image2d_t inputA,\n"
                  " __read_only image2d_t inputB,\n"
                  " __write_only image2d_t output,const int width,\n"
                  " const int height) {\n"
                  " const int2 pos=(int2)(get_global_id(0),get_global_id(1));\n"
                  " if (pos.x >= width || pos.y >= height) {\n"
                  " return;\n"
                  " }\n"
                  " // Use read_imageh to read half4 vector\n"
                  " half4 inA=read_imageh(inputA,sampler,pos);\n"
                  " half4 inB=read_imageh(inputB,sampler,pos);\n"
                  " half4 result=inA+inB;\n"
                  " // Use write_imageh to write back half4 vector\n"
                  " write_imageh(output,pos,result);\n"
                  "}\n"
                  "// ==================================================================\n"
                  "// 4. Tensor+Scalar Kernels\n"
                  "// ==================================================================\n"
                  "/**\n"
                  "*@brief [FP32 Buffer Version] Add a scalar `B` to each element of tensor `A`.\n"
                  " */\n"
                  "__kernel void add_scalar_float(__global const float *A,const float B,\n"
                  " __global float *C) {\n"
                  " size_t index=get_global_id(0);\n"
                  " C[index]=A[index]+B;\n"
                  "}\n"
                  "/**\n"
                  "*@brief [FP16 Buffer Version] Use vector instructions to add a scalar `B` to\n"
                  "*each element of tensor `A`.\n"
                  " */\n"
                  "__kernel void add_scalar_fp16_vector(__global const half *A,const half B,\n"
                  " __global half *C) {\n"
                  " const int i=get_global_id(0);\n"
                  " half4 a_vec=vload4(i,A);\n"
                  " // Broadcast scalar B to a half4 vector\n"
                  " half4 b_vec=(half4)(B);\n"
                  " half4 c_vec=a_vec+b_vec;\n"
                  " vstore4(c_vec,i,C);\n"
                  "}\n"
                  "/**\n"
                  "*@brief [FP32 Image Version] Add a scalar `B` to each pixel of tensor `A`.\n"
                  " */\n"
                  "__kernel void add_scalar_float_image2d(sampler_t sampler,\n"
                  " __read_only image2d_t inputA,\n"
                  " const float B,\n"
                  " __write_only image2d_t output,\n"
                  " const int width,const int height) {\n"
                  " const int2 pos=(int2)(get_global_id(0),get_global_id(1));\n"
                  " if (pos.x >= width || pos.y >= height) {\n"
                  " return;\n"
                  " }\n"
                  " float4 inA=read_imagef(inputA,sampler,pos);\n"
                  " // Broadcast scalar B to a float4 vector\n"
                  " float4 inB=(float4)(B);\n"
                  " float4 result=inA+inB;\n"
                  " write_imagef(output,pos,result);\n"
                  "}\n"
                  "/**\n"
                  "*@brief [FP16 Image Version] Add a scalar `B` to each pixel of tensor `A`.\n"
                  " */\n"
                  "__kernel void add_scalar_fp16_image2d(sampler_t sampler,\n"
                  " __read_only image2d_t inputA,\n"
                  " const half B,\n"
                  " __write_only image2d_t output,\n"
                  " const int width,const int height) {\n"
                  " const int2 pos=(int2)(get_global_id(0),get_global_id(1));\n"
                  " if (pos.x >= width || pos.y >= height) {\n"
                  " return;\n"
                  " }\n"
                  " half4 inA=read_imageh(inputA,sampler,pos);\n"
                  " // Broadcast scalar B to a half4 vector\n"
                  " half4 inB=(half4)(B);\n"
                  " half4 result=inA+inB;\n"
                  " write_imageh(output,pos,result);\n"
                  "}\n";
}  // namespace mllm::opencl
