#include "a_opencl_source_map.hpp"
namespace mllm::opencl {
const char* add =
    "__kernel void add_float(\n"
    " __global const float *A,\n"
    " __global const float *B,\n"
    " __global float *C) {\n"
    " size_t index=get_global_id(0);\n"
    " C[index]=A[index]+B[index];\n"
    "}\n"
    "/*\n"
    "*Define a global sampler. A sampler is used to configure how data is read from image objects.\n"
    "*CLK_NORMALIZED_COORDS_FALSE: Use non-normalized integer coordinates (pixel coordinates) instead of floating point "
    "coordinates in [0.0,1.0].\n"
    "*CLK_ADDRESS_CLAMP_TO_EDGE: When reading coordinates beyond the image boundary,automatically return the pixel value of "
    "the nearest edge to prevent out-of-bounds reading.\n"
    "*CLK_FILTER_NEAREST: Read the pixel closest to the coordinate without interpolation,which is essential for data "
    "calculation.\n"
    " */\n"
    "// const sampler_t sampler=CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_NEAREST;\n"
    "/**\n"
    "*@brief Efficiently perform element-wise addition of two float tensors using image2d_t.\n"
    "*@param sampler Sampler object used to read images.\n"
    "*@param inputA Input tensor A,as a read-only 2D image object.\n"
    "*@param inputB Input tensor B,as a read-only 2D image object.\n"
    "*@param output Output tensor C,as a write-only 2D image object.\n"
    "*@param width Logical width of the image (in pixels).\n"
    "*@param height Logical height of the image (in pixels).\n"
    " */\n"
    "__kernel void add_float_image2d(\n"
    " sampler_t sampler,// Sampler is now the first parameter\n"
    " __read_only image2d_t inputA,\n"
    " __read_only image2d_t inputB,\n"
    " __write_only image2d_t output,\n"
    " const int width,\n"
    " const int height) {\n"
    " const int2 pos=(int2)(get_global_id(0),get_global_id(1));\n"
    " if (pos.x >= width || pos.y >= height) {\n"
    " return;\n"
    " }\n"
    " float4 inA=read_imagef(inputA,sampler,pos);\n"
    " float4 inB=read_imagef(inputB,sampler,pos);\n"
    " float4 result=inA+inB;\n"
    " write_imagef(output,pos,result);\n"
    "}\n"
    "#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n"
    "/**\n"
    "*@brief [FP16 Buffer Version] Efficiently perform element-wise addition of two half tensors using vector instructions.\n"
    "*The kernel uses vload4/vstore4 to process 4 half elements at once.\n"
    "*@param A Input tensor A (__global const half*)\n"
    "*@param B Input tensor B (__global const half*)\n"
    "*@param C Output tensor C (__global half*)\n"
    " */\n"
    "__kernel void add_fp16_vector(\n"
    " __global const half *A,\n"
    " __global const half *B,\n"
    " __global half *C) {\n"
    " const int i=get_global_id(0);\n"
    " // Efficiently load 4 half (total 64 bits) data\n"
    " half4 a_vec=vload4(i,A);\n"
    " half4 b_vec=vload4(i,B);\n"
    " // Vector addition\n"
    " half4 c_vec=a_vec+b_vec;\n"
    " // Efficiently write back 4 half data\n"
    " vstore4(c_vec,i,C);\n"
    "}\n"
    "/**\n"
    "*@brief [FP16 Image Version] Efficiently perform element-wise addition of two half tensors using image2d_t.\n"
    "*Utilize hardware texture cache and read_imageh/write_imageh functions.\n"
    "*@param sampler Sampler object used to read images.\n"
    "*@param inputA Input tensor A,as a read-only 2D image object (data type is half).\n"
    "*@param inputB Input tensor B,as a read-only 2D image object (data type is half).\n"
    "*@param output Output tensor C,as a write-only 2D image object (data type is half).\n"
    "*@param width Logical width of the image (in pixels).\n"
    "*@param height Logical height of the image (in pixels).\n"
    " */\n"
    "__kernel void add_fp16_image2d(\n"
    " sampler_t sampler,\n"
    " __read_only image2d_t inputA,\n"
    " __read_only image2d_t inputB,\n"
    " __write_only image2d_t output,\n"
    " const int width,\n"
    " const int height) {\n"
    " const int2 pos=(int2)(get_global_id(0),get_global_id(1));\n"
    " if (pos.x >= width || pos.y >= height) {\n"
    " return;\n"
    " }\n"
    " // Use read_imageh to read half4 vector\n"
    " half4 inA=read_imageh(inputA,sampler,pos);\n"
    " half4 inB=read_imageh(inputB,sampler,pos);\n"
    " half4 result=inA+inB;\n"
    " // Use write_imageh to write back half4 vector\n"
    " write_imageh(output,pos,result);\n"
    "}\n"
    "// ==================================================================\n"
    "// 4. Tensor+Scalar Kernels\n"
    "// ==================================================================\n"
    "/**\n"
    "*@brief [FP32 Buffer Version] Add a scalar `B` to each element of tensor `A`.\n"
    " */\n"
    "__kernel void add_scalar_float(\n"
    " __global const float *A,\n"
    " const float B,\n"
    " __global float *C) {\n"
    " size_t index=get_global_id(0);\n"
    " C[index]=A[index]+B;\n"
    "}\n"
    "/**\n"
    "*@brief [FP16 Buffer Version] Use vector instructions to add a scalar `B` to each element of tensor `A`.\n"
    " */\n"
    "__kernel void add_scalar_fp16_vector(\n"
    " __global const half *A,\n"
    " const half B,\n"
    " __global half *C) {\n"
    " const int i=get_global_id(0);\n"
    " half4 a_vec=vload4(i,A);\n"
    " // Broadcast scalar B to a half4 vector\n"
    " half4 b_vec=(half4)(B);\n"
    " half4 c_vec=a_vec+b_vec;\n"
    " vstore4(c_vec,i,C);\n"
    "}\n"
    "/**\n"
    "*@brief [FP32 Image Version] Add a scalar `B` to each pixel of tensor `A`.\n"
    " */\n"
    "__kernel void add_scalar_float_image2d(\n"
    " sampler_t sampler,\n"
    " __read_only image2d_t inputA,\n"
    " const float B,\n"
    " __write_only image2d_t output,\n"
    " const int width,\n"
    " const int height) {\n"
    " const int2 pos=(int2)(get_global_id(0),get_global_id(1));\n"
    " if (pos.x >= width || pos.y >= height) { return; }\n"
    " float4 inA=read_imagef(inputA,sampler,pos);\n"
    " // Broadcast scalar B to a float4 vector\n"
    " float4 inB=(float4)(B);\n"
    " float4 result=inA+inB;\n"
    " write_imagef(output,pos,result);\n"
    "}\n"
    "/**\n"
    "*@brief [FP16 Image Version] Add a scalar `B` to each pixel of tensor `A`.\n"
    " */\n"
    "__kernel void add_scalar_fp16_image2d(\n"
    " sampler_t sampler,\n"
    " __read_only image2d_t inputA,\n"
    " const half B,\n"
    " __write_only image2d_t output,\n"
    " const int width,\n"
    " const int height) {\n"
    " const int2 pos=(int2)(get_global_id(0),get_global_id(1));\n"
    " if (pos.x >= width || pos.y >= height) { return; }\n"
    " half4 inA=read_imageh(inputA,sampler,pos);\n"
    " // Broadcast scalar B to a half4 vector\n"
    " half4 inB=(half4)(B);\n"
    " half4 result=inA+inB;\n"
    " write_imageh(output,pos,result);\n"
    "}\n";
}  // namespace mllm::opencl
