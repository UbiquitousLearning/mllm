// Copyright (c) MLLM Team.
// Licensed under the MIT License.

// GENERATED BY AGENT !!!
// SHOULD REVIEW AGAIN !!!

#include <nlohmann/json.hpp>

#include "mllm/core/DataTypes.hpp"
#include "mllm/core/aops/MatMulOp.hpp"
#include "mllm/core/aops/TransposeOp.hpp"
#include "mllm/core/aops/CastTypeOp.hpp"
#include "mllm/core/aops/FlashAttention2Op.hpp"
#include "mllm/core/aops/KVCacheOp.hpp"
#include "mllm/core/aops/MultimodalRoPEOp.hpp"
#include "mllm/core/aops/VisionRoPEOp.hpp"
#include "mllm/core/aops/ViewOp.hpp"
#include "mllm/core/aops/SplitOp.hpp"
#include "mllm/core/aops/RepeatOp.hpp"
#include "mllm/core/aops/PermuteOp.hpp"
#include "mllm/core/aops/SliceOp.hpp"
#include "mllm/core/aops/ParamOp.hpp"
#include "mllm/core/aops/IndexOp.hpp"
#include "mllm/core/aops/ConcatOp.hpp"
#include "mllm/core/aops/ReduceOps.hpp"
#include "mllm/core/aops/TopKOp.hpp"
#include "mllm/core/aops/ElewiseOps.hpp"
#include "mllm/core/aops/EmbeddingOp.hpp"
#include "mllm/core/aops/LinearOp.hpp"
#include "mllm/compile/jit/binary/LinalgIRSerialization.hpp"

namespace mllm::jit::binary {

nlohmann::json dumpLinalgIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  MLLM_RT_ASSERT(op->getAOp() != nullptr);

#define CASE(op_type) \
  case OpTypes::k##op_type: return dump##op_type##OpIROptions(op);

  switch (op->getAOp()->getOpType()) {
    CASE(Fill)
    CASE(Add)
    CASE(Sub)
    CASE(Mul)
    CASE(Div)
    CASE(Abs)
    CASE(Log)
    CASE(MatMul)
    CASE(Embedding)
    CASE(Linear)
    CASE(RoPE)
    CASE(KVCache)
    CASE(CausalMask)
    CASE(Softmax)
    CASE(Transpose)
    CASE(RMSNorm)
    CASE(SiLU)
    CASE(CastType)
    CASE(X2X)
    CASE(View)
    CASE(Split)
    CASE(STFT)
    CASE(FlashAttention2)
    CASE(Repeat)
    CASE(Permute)
    CASE(Conv1D)
    CASE(Conv2D)
    CASE(Conv3D)
    CASE(GELU)
    CASE(LayerNorm)
    CASE(MultimodalRoPE)
    CASE(VisionRoPE)
    CASE(QuickGELU)
    CASE(Copy)
    CASE(Clone)
    CASE(Neg)
    CASE(Concat)
    CASE(ReduceMax)
    CASE(ReduceMin)
    CASE(ReduceSum)
    CASE(ReLU)
    CASE(Contiguous)
    CASE(Reshape)
    CASE(Slice)
    CASE(Param)
    CASE(Index)
    CASE(TopK)
    CASE(Mean)
    CASE(Clip)
    default: break;
  }

#undef CASE

  return {};
}

// Dump functions for each LinalgIR operation - all return empty JSON by default
nlohmann::json dumpFillOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpAddOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpSubOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpMulOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpDivOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpAbsOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpLogOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpMatMulOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::MatMulOp*)op->getAOp())->options();
  return {{"transpose_a", options.transpose_a},
          {"transpose_b", options.transpose_b},
          {"matmul_type", MatMulOpType2Str(options.matmul_type)}};
}

nlohmann::json dumpEmbeddingOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::EmbeddingOp*)op->getAOp())->options();
  return {{"vocab_size", options.vocab_size}, {"hidden_size", options.hidden_size}};
}

nlohmann::json dumpLinearOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::LinearOp*)op->getAOp())->options();
  return {{"in_channels", options.in_channels},
          {"out_channels", options.out_channels},
          {"bias", options.bias},
          {"impl_type", LinearImplTypes2Str(options.impl_type)}};
}

nlohmann::json dumpRoPEOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpKVCacheOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::KVCacheOp*)op->getAOp())->options();
  return {{"layer_idx", options.layer_idx},
          {"q_head", options.q_head},
          {"kv_head", options.kv_head},
          {"head_dim", options.head_dim},
          {"use_fa2", options.use_fa2}};
}

nlohmann::json dumpCausalMaskOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpSoftmaxOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpTransposeOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::TransposeOp*)op->getAOp())->options();
  return {{"dim0", options.dim0}, {"dim1", options.dim1}};
}

nlohmann::json dumpRMSNormOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpSiLUOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpCastTypeOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::CastTypeOp*)op->getAOp())->options();
  return {{"dtype", nameOfType(options.dtype)}};
}

nlohmann::json dumpX2XOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpViewOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::ViewOp*)op->getAOp())->options();
  nlohmann::json j;
  j["to_shape"] = options.to_shape;
  return j;
}

nlohmann::json dumpSplitOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::SplitOp*)op->getAOp())->options();
  nlohmann::json j;
  j["dim"] = options.dim;
  j["split_size_or_sections"] = nlohmann::json::array();
  for (const auto& size : options.split_size_or_sections) { j["split_size_or_sections"].push_back(size); }
  return j;
}

nlohmann::json dumpSTFTOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpFlashAttention2OpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::FlashAttention2Op*)op->getAOp())->options();
  return {{"B", options.B}, {"q_head", options.q_head}, {"kv_head", options.kv_head},
          {"D", options.D}, {"hp_exp", options.hp_exp}, {"causal_mask", options.causal_mask}};
}

nlohmann::json dumpRepeatOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::RepeatOp*)op->getAOp())->options();
  return {{"dim", options.dim}, {"repeat_times", options.repeat_times}};
}

nlohmann::json dumpPermuteOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::PermuteOp*)op->getAOp())->options();
  nlohmann::json j;
  j["axis"] = nlohmann::json::array();
  for (const auto& ax : options.axis) { j["axis"].push_back(ax); }
  return j;
}

nlohmann::json dumpConv1DOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpConv2DOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpConv3DOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpGELUOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpLayerNormOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpMultimodalRoPEOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::MultimodalRoPEOp*)op->getAOp())->options();
  nlohmann::json j;
  j["type"] = static_cast<int>(options.type);

  switch (options.type) {
    case aops::MultimodalRoPEOpOptionsType::kQwen2VL: {
      j["qwen2vl_options"] = {{"rope_theta", options.qwen2vl_options.rope_theta},
                              {"max_position_embeddings", options.qwen2vl_options.max_position_embeddings}};
      nlohmann::json mrope_section_json = nlohmann::json::array();
      for (const auto& section : options.qwen2vl_options.mrope_section) { mrope_section_json.push_back(section); }
      j["qwen2vl_options"]["mrope_section"] = mrope_section_json;
      break;
    }
    default: break;
  }
  return j;
}

nlohmann::json dumpVisionRoPEOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::VisionRoPEOp*)op->getAOp())->options();
  nlohmann::json j;
  j["type"] = static_cast<int>(options.type);

  switch (options.type) {
    case aops::VisionRoPEOpOptionsType::kQwen2VL: {
      j["qwen2vl_rope_op_options"] = {{"dims", options.qwen2vl_rope_op_options.dims},
                                      {"spatial_merge_size", options.qwen2vl_rope_op_options.spatial_merge_size},
                                      {"theta", options.qwen2vl_rope_op_options.theta}};
      break;
    }
    default: break;
  }
  return j;
}

nlohmann::json dumpQuickGELUOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpCopyOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpCloneOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpNegOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpConcatOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::ConcatOp*)op->getAOp())->options();
  return {{"dim", options.dim}};
}

nlohmann::json dumpReduceMaxOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::ReduceMaxOp*)op->getAOp())->options();
  return {{"dim", options.dim}, {"keep_dim", options.keep_dim}};
}

nlohmann::json dumpReduceMinOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::ReduceMinOp*)op->getAOp())->options();
  return {{"dim", options.dim}, {"keep_dim", options.keep_dim}};
}

nlohmann::json dumpReduceSumOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::ReduceSumOp*)op->getAOp())->options();
  return {{"dim", options.dim}, {"keep_dim", options.keep_dim}};
}

nlohmann::json dumpReLUOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpContiguousOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpReshapeOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) { return {}; }

nlohmann::json dumpSliceOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::SliceOp*)op->getAOp())->options();
  nlohmann::json j;
  j["indices"] = nlohmann::json::array();

  for (const auto& slice_pair : options.indices_) {
    nlohmann::json slice_json;
    slice_json["start"] = slice_pair.start_;
    slice_json["end"] = slice_pair.end_;
    slice_json["step"] = slice_pair.step_;
    j["indices"].push_back(slice_json);
  }

  return j;
}
nlohmann::json dumpParamOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::ParamOp*)op->getAOp())->options();
  nlohmann::json j;
  j["name"] = options.name;
  j["shape"] = nlohmann::json::array();
  for (const auto& dim : options.shape) { j["shape"].push_back(dim); }
  return j;
}

nlohmann::json dumpIndexOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::IndexOp*)op->getAOp())->options();
  MLLM_WARN("dumpIndexOpIROptions are not supported yet");
  return {};
}

nlohmann::json dumpTopKOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::TopKOp*)op->getAOp())->options();
  return {{"k", options.k}, {"dim", options.dim}, {"largest", options.largest}, {"sorted", options.sorted}};
}

nlohmann::json dumpMeanOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::MeanOp*)op->getAOp())->options();
  return {{"dim", options.dim}, {"keep_dim", options.keep_dim}};
}

nlohmann::json dumpClipOpIROptions(const ir::linalg::LinalgIROp::ptr_t& op) {
  auto options = ((aops::ClipOp*)op->getAOp())->options();
  return {{"min_val", options.min_val}, {"max_val", options.max_val}};
}

}  // namespace mllm::jit::binary
